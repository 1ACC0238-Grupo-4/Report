# **Informe Trabajo Final**

<p align="center">
  <img src="https://github.com/WorkStation-MarronCoders/Report/raw/main/Imagenes/upc_logo.png" alt="Logo de la UPC" />
</p>

<p align="center"><strong>Universidad Peruana de Ciencias Aplicadas</strong></p>

<p align="center"><strong>Ingeniería de Software</strong><br>
Aplicaciones para dispositivos moviles <br>
<strong>Profesor: Jorge Luis Mayta Guillermo</strong> </p>

<h2 align="center">INFORME</h2>

<h3 align="center">Startup: Grupo 3</h3>
<p align="center"><strong>Producto: Workstation</strong></p>

<h3 align="center">Team Members:</h3>

<div align="center">

| **Member**               | **Code**   |
| ------------------------ | ---------- |
| Rodrigo Liberato Saldana | U202215623 |
|                          |            |
|                          |            |
|                          |            |
|                          |            |

</div>

<p align="center"><strong>Septiembre 2025</strong></p>

# Registro de Versiones del Informe

# Project Report Collaboration Insights

## Contenido

### Tabla de contenidos

- [Student Outcome (ver anexo A)](#student-outcome-ver-anexo-a)
- [Objetivos SMART](#objetivos-smart)
- [Capítulo I: Presentación](#capítulo-i-presentación)

  - [1.1. Startup Profile](#11-startup-profile)
    - [1.1.1. Descripción de la Startup](#111-descripción-de-la-startup)
    - [1.1.2. Perfiles de integrantes del equipo](#112-perfiles-de-integrantes-del-equipo)
  - [1.2. Solution Profile](#12-solution-profile)
    - [1.2.1. Antecedentes y problemática](#121-antecedentes-y-problemática)
    - [1.2.2. Lean UX Process](#122-lean-ux-process)
      - [1.2.2.1. Lean UX Problem Statements](#1221-lean-ux-problem-statements)
      - [1.2.2.2. Lean UX Assumptions](#1222-lean-ux-assumptions)
      - [1.2.2.3. Lean UX Hypothesis Statements](#1223-lean-ux-hypothesis-statements)
      - [1.2.2.4. Lean UX Canvas](#1224-lean-ux-canvas)
  - [1.3. Segmentos objetivo](#13-segmentos-objetivo)

- [Capítulo II: Requirements Development and Software Solution Design](#capítulo-ii-requirements-development-and-software-solution-design)
  - [2.1. Competidores](#21-competidores)
    - [2.1.1. Análisis competitivo](#211-análisis-competitivo)
    - [2.1.2. Estrategias y tácticas frente a competidores](#212-estrategias-y-tácticas-frente-a-competidores)
  - [2.2. Entrevistas](#22-entrevistas)
    - [2.2.1. Diseño de entrevistas](#221-diseño-de-entrevistas)
    - [2.2.2. Registro de entrevistas](#222-registro-de-entrevistas)
    - [2.2.3. Análisis de entrevistas](#223-análisis-de-entrevistas)
  - [2.3. Needfinding](#23-needfinding)
    - [2.3.1. User Personas](#231-user-personas)
    - [2.3.2. User Task Matrix](#232-user-task-matrix)
    - [2.3.3. User Journey Mapping](#233-user-journey-mapping)
    - [2.3.4. Empathy Mapping](#234-empathy-mapping)
    - [2.3.5. Ubiquitous Language](#235-ubiquitous-language)
  - [2.4. Requirements specification](#24-requirements-specification)
    - [2.4.1. User Stories](#241-user-stories)
    - [2.4.2. Impact Mapping](#242-impact-mapping)
    - [2.4.3. Product Backlog](#243-product-backlog)
  - [2.5. Strategic-Level Domain-Driven Design](#25-strategic-level-domain-driven-design)
    - [2.5.1. EventStorming](#251-eventstorming)
      - [2.5.1.1. Candidate Context Discovery](#2511-candidate-context-discovery)
      - [2.5.1.2. Domain Message Flows Modeling](#2512-domain-message-flows-modeling)
      - [2.5.1.3. Bounded Context Canvases](#2513-bounded-context-canvases)
    - [2.5.2. Context Mapping](#252-context-mapping)
    - [2.5.3. Software Architecture](#253-software-architecture)
      - [2.5.3.1. Software Architecture Context Level Diagrams](#2531-software-architecture-context-level-diagrams)
      - [2.5.3.2. Software Architecture Container Level Diagrams](#2532-software-architecture-container-level-diagrams)
      - [2.5.3.3. Software Architecture Deployment Diagrams](#2533-software-architecture-deployment-diagrams)
  - [2.6. Tactical-Level Domain-Driven Design](#26-tactical-level-domain-driven-design)
    - [2.6.x. Bounded Context: <Bounded Context Name>](#26x-bounded-context-bounded-context-name)
      - [2.6.x.1. Domain Layer](#26x1-domain-layer)
      - [2.6.x.2. Interface Layer](#26x2-interface-layer)
      - [2.6.x.3. Application Layer](#26x3-application-layer)
      - [2.6.x.4. Infrastructure Layer](#26x4-infrastructure-layer)
      - [2.6.x.5. Bounded Context Software Architecture Component Level Diagrams](#26x5-bounded-context-software-architecture-component-level-diagrams)
      - [2.6.x.6. Bounded Context Software Architecture Code Level Diagrams](#26x6-bounded-context-software-architecture-code-level-diagrams)
        - [2.6.x.6.1. Bounded Context Domain Layer Class Diagrams](#26x61-bounded-context-domain-layer-class-diagrams)
        - [2.6.x.6.2. Bounded Context Database Design Diagram](#26x62-bounded-context-database-design-diagram)

---

## Student Outcome (ver anexo A)

## Objetivos SMART

# Capítulo I: Presentación

## 1.1. Startup Profile

### 1.1.1. Descripción de la Startup

### 1.1.2. Perfiles de integrantes del equipo

## 1.2. Solution Profile

### 1.2.1. Antecedentes y problemática

### 1.2.2. Lean UX Process

#### 1.2.2.1. Lean UX Problem Statements

#### 1.2.2.2. Lean UX Assumptions

#### 1.2.2.3. Lean UX Hypothesis Statements

#### 1.2.2.4. Lean UX Canvas

## 1.3. Segmentos objetivo

# Capítulo II: Requirements Development and Software Solution Design

## 2.1. Competidores

### 2.1.1. Análisis competitivo

### 2.1.2. Estrategias y tácticas frente a competidores

## 2.2. Entrevistas

### 2.2.1. Diseño de entrevistas

### 2.2.2. Registro de entrevistas

### 2.2.3. Análisis de entrevistas

## 2.3. Needfinding

### 2.3.1. User Personas

### 2.3.2. User Task Matrix

### 2.3.3. User Journey Mapping

### 2.3.4. Empathy Mapping

### 2.3.5. Ubiquitous Language

## 2.4. Requirements specification

### 2.4.1. User Stories

### 2.4.2. Impact Mapping

### 2.4.3. Product Backlog

## 2.5. Strategic-Level Domain-Driven Design

### 2.5.1. EventStorming

#### 2.5.1.1. Candidate Context Discovery

#### 2.5.1.2. Domain Message Flows Modeling

#### 2.5.1.3. Bounded Context Canvases

### 2.5.2. Context Mapping

### 2.5.3. Software Architecture

#### 2.5.3.1. Software Architecture Context Level Diagrams

#### 2.5.3.2. Software Architecture Container Level Diagrams

#### 2.5.3.3. Software Architecture Deployment Diagrams

## 2.6. Tactical-Level Domain-Driven Design

### 2.6.1. Bounded Context: User

En esta seccion seccion, el Contexto de Usuario abarca nuestros dos segmentos objetivos, siendo personas que buscan las oficinas para rentar y las Personas que podran ofrecer estas oficinas. Si bien tienen diferentes roles, solo las personas que se registren con el objetivo de registrar las oficinas tendran esa opcion habilitada.

**Nombre de la clase:** User
**Proposito:** Albergar la informacion personal de los usuarios que se registren en la aplicacion.
**Atributos y metodos:** Los atributos que posee son:UserId, FirstName, LastName, Dni, PhoneNumber, Email, Role y CreatedAt. Los metodos principales que posee son los de CreateUser(), UpdateUser() y DeleteUser().
**Relaciones:** Mantiene una relacion la clase de Offices debido a que es la principal clase de la aplicacion y los usuarios con el rol indicado podran tener el acceso a tener muchas oficinas a la renta, ademas de la clase Messages y Rating, que se basan en el accionar del usuario y podran tener muchas.

#### 2.6.1.1. Domain Layer

En esta seccion se ira mas a profundidad acerca de lo que posee la capa del Dominio.

**Entidades:** Las entidades que posee este contexto son: User
**Value Objects**: Los Value Objects son: UserRole
**Domain Services:** Los servicios son tales como el CreateUser, delete, update, Login, IHash y IJwtEncrypt para la seguridad del usuario.
**Repositories**: Se accedio por los datos por medio de un Repositorio, IUserRepository con los emtodos de GetByEmailAsync, GetPhoneNumberAsync y GetByDniAsync.

#### 2.6.1.2. Interface Layer

Las clases de presentacion que se crearon para la presentacion de los usuarios fue utilizando REST ademas de utilizar recursos y transformadores para que se muestre solo la informacion requerida.

**Controllers:** El UserController posee endpoints como GetAllUsers, GetUserById, CreateUser, UpdateUser, DeleteUser y Login.
**Resources and Transformers:** Los recursos que se crearon para este contexto fue el de UserResource que posee firstName, lastName, dni, phoneNumber, email, roles y password. Asimismo se creo un transformador para recibir la misma informacion desde el otro lado donde se use la API.

#### 2.6.1.3. Application Layer

Para manejar los procesos de negocio, aqui se encuentran los servicios de Comandos, Queries y Hash.

**Commandos:** UserCommand posee los comandos basicos mencionados con anterioridad (create, update, delete y login) ademas de poseer validaciones con los datos que se ingresan en la Aplicacion.
**Queries:** UserQuery posee dos metodos, GetAllUsers y GetUserById, estos se usan para algunas validaciones o para mostrar datos por medio de la capa de Interfaz.
**Hash:** Para la seguridad del usuario se encriptan las contraseñas con los servicios de Hash y JwtEncript.

#### 2.6.1.4. Infrastructure Layer

Para los servicios externos solo se creo un Repositorio:

**Repositorio:** UserRepository maneja la informacion para verificaciones de Dni, Email y numero de celular

#### 2.6.1.5. Bounded Context Software Architecture Component Level Diagrams

![ComponentDiagram1](https://github.com/WorkStation-MarronCoders/Report/raw/main/Imagenes/DDD4_UserAP.png)

#### 2.6.1.6. Bounded Context Software Architecture Code Level Diagrams

##### 2.6.1.6.1. Bounded Context Domain Layer Class Diagrams

![ClassDiagram](https://media.discordapp.net/attachments/766316535290789908/1417671581634924664/XL9jJW8n4FtVK_IdHE406wCiB2g9ebdb08KECaa_IDl56FNkjhDGTzM4FxkTDwzltinqx8DmeT6AhPNmda-4Xva96Dxv1-FydCybB_XjWvAYgGCHG5Rn4-7qUq4Db7gm4ZVu9tTDoQK7HqfeGWliP1BguYrpxijrm7sIM5chs1TZO1fD2hLLGBRAkfujgh9wh6CmMJvFwHYfr0HnYJVa.png?ex=68cb550c&is=68ca038c&hm=993b1bfb6192bdf31c4f2dc5fda1141347898ce7803f7ad3a200245b961a4372&=&format=webp&quality=lossless)

##### 2.6.1.6.2. Bounded Context Database Design Diagram

![DatabaseDiagram](https://media.discordapp.net/attachments/766316535290789908/1417671581236461609/XLBDIiD04BxdAOQS6h5IXLvAAQssnT1Qef07c6H7Cf1iT7TI4UExknkgJGJnakpEzpCpNxAqWaQQgWn82yixXBTeQTETGq0BcRkUe8y0u09Y1JDeDBysnCeZpqm6vlDajrWumfqX559hzt0yvLx25JdWeLQU-Xk1GxhVEpYrP3fhrkAlBvwW-jLlPcnNkV3HcsGimMVmCxfdssxgnf_-.png?ex=68cb550c&is=68ca038c&hm=dee65a9589aa9ee8646c03c5ba2fdb8d8b659bee7e3eef35d38b85c305a733c0&=&format=webp&quality=lossless)

---

### 2.6.3. Bounded Context: Office

Office es el principal contexto que se utiliza en la aplicacion, debido a que es donde se manejan la creacion de las oficinas, las reservas, los servicios ofrecidos y cuando es que sera posible de reservar nuevamente.l

**Nombre de la clase:** Office
**Proposito:** Albergar la informacion de las oficinas que se registren por parte de los Dueños de oficinas en la aplicacion, ademas de mostrar su disponibilidad y la cantidad de servicios.
**Atributos y metodos:** Los atributos que posee son: OfficeId, Location, Description, ImageUrl, Capacity, CostPerDay, IsActive, Available y Services. Los metodos principales que posee son los de CreateOffice(), UpdateOffice(), DeleteOffice(), asimismo de la creacion de Servicios de oficinas. En cuanto a los Queries, poseen GetAllOffices, GetOfficeById y GetOfficeByLocation.
**Relaciones:** Mantiene una relacion las clases de Users y Rating debido a que las oficinas solo pueden tener un dueño y tener muchos ratings.

#### 2.6.3.1. Domain Layer

En esta seccion se ira mas a profundidad acerca de lo que posee la capa del Dominio.

**Entidades:** Las entidades que posee este contexto son: Office
**Value Objects**: Los Value Objects son: OfficeService
**Domain Services:** Los servicios son tales como el Create, Delete, Update por parte de las oficinas y los servicios de las oficinas.
**Repositories**: Se accedio por los datos por medio de un Repositorio, IOfficeRepository con los emtodos de GetByLocationAsync.

#### 2.6.3.2. Interface Layer

Las clases de presentacion que se crearon para la presentacion de los usuarios fue utilizando REST ademas de utilizar recursos y transformadores para que se muestre solo la informacion requerida.

**Controllers:** El OfficeController posee endpoints como GetAllOfficesAsync, GetOfficeByIdAsync, GetOfficeByLocationAsync, CreateOfficeAsync, UpdateOfficeAsync y DeleteOfficeAsync.
**Resources and Transformers:** Los recursos que se crearon para este contexto fue el de OfficeResource que posee Location, Description, ImageUrl, Capacity, CostPerDay, Available y una lista de OfficesResource, que posee a su vez: Name, Description y Cost. Asimismo se creo un transformador para recibir la misma informacion desde el otro lado donde se use la API.

#### 2.6.3.3. Application Layer

Para manejar los procesos de negocio, aqui se encuentran los servicios de Comandos, Queries y Hash.

**Commandos:** OfficeCommand posee los comandos basicos mencionados con anterioridad (create, update y delete) ademas de poseer validaciones con los datos que se ingresan en la aplicacion.
**Queries:** OfficeQueryService posee dos metodos, GetAllOfficesQuery, GetOfficeByIdQuery y GetOfficeByLocation estos se usan para algunas validaciones o para mostrar datos por medio de la capa de Interfaz.

#### 2.6.3.4. Infrastructure Layer

Para los servicios externos solo se creo un Repositorio:

**Repositorio:** OfficeRepository maneja la informacion para verificaciones de Location.

#### 2.6.3.5. Bounded Context Software Architecture Component Level Diagrams

![ComponentDiagram2](https://github.com/WorkStation-MarronCoders/Report/raw/main/Imagenes/DDD5_officeAP.png)

#### 2.6.3.6. Bounded Context Software Architecture Code Level Diagrams

##### 2.6.3.6.1. Bounded Context Domain Layer Class Diagrams

![ClassDiagram](https://media.discordapp.net/attachments/766316535290789908/1417678179551805551/XLFTJi8m5BxVKpIx0dKNtYu4mM4C2Vv4vG5ATo0dwTQbFP0OzDrjj-Ceq-WDhD_vThwVT3D7qjA-qedIqZbnAntSrOJqBew949TYMOfStE-nR4-51KbGBloFXyFV6rRGZXvCYLlyCRjfXsi7jjs4DNL0KuP5CTunbswk20zXnSOOdNmcxEnfkqK5x6fbb2GqjMSvibZlMdG1JbbipWQy.png?ex=68cb5b31&is=68ca09b1&hm=827dff612fb42a3147106daea4b2674a016ddac888f9fbcfb2567d488ec9c255&=&format=webp&quality=lossless)

##### 2.6.3.6.2. Bounded Context Database Design Diagram

![DatabaseDiagram](https://media.discordapp.net/attachments/766316535290789908/1417678179551805551/XLFTJi8m5BxVKpIx0dKNtYu4mM4C2Vv4vG5ATo0dwTQbFP0OzDrjj-Ceq-WDhD_vThwVT3D7qjA-qedIqZbnAntSrOJqBew949TYMOfStE-nR4-51KbGBloFXyFV6rRGZXvCYLlyCRjfXsi7jjs4DNL0KuP5CTunbswk20zXnSOOdNmcxEnfkqK5x6fbb2GqjMSvibZlMdG1JbbipWQy.png?ex=68cb5b31&is=68ca09b1&hm=827dff612fb42a3147106daea4b2674a016ddac888f9fbcfb2567d488ec9c255&=&format=webp&quality=lossless)

---

### 2.6.4. Bounded Context: Messaging

#### 2.6.4.1. Domain Layer

#### 2.6.4.2. Interface Layer

#### 2.6.4.3. Application Layer

#### 2.6.4.4. Infrastructure Layer

#### 2.6.4.5. Bounded Context Software Architecture Component Level Diagrams

#### 2.6.4.6. Bounded Context Software Architecture Code Level Diagrams

##### 2.6.4.6.1. Bounded Context Domain Layer Class Diagrams

##### 2.6.4.6.2. Bounded Context Database Design Diagram

---

### 2.6.6. Bounded Context: Rating

#### 2.6.6.1. Domain Layer

#### 2.6.6.2. Interface Layer

#### 2.6.6.3. Application Layer

#### 2.6.6.4. Infrastructure Layer

#### 2.6.6.5. Bounded Context Software Architecture Component Level Diagrams

#### 2.6.6.6. Bounded Context Software Architecture Code Level Diagrams

##### 2.6.6.6.1. Bounded Context Domain Layer Class Diagrams

##### 2.6.6.6.2. Bounded Context Database Design Diagram
