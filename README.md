# **Informe Trabajo Final**

<p align="center">
  <img src="https://github.com/WorkStation-MarronCoders/Report/raw/main/Imagenes/upc_logo.png" alt="Logo de la UPC" />
</p>

<p align="center"><strong>Universidad Peruana de Ciencias Aplicadas</strong></p>

<p align="center"><strong>Ingeniería de Software</strong><br>
Aplicaciones para dispositivos moviles <br>
<strong>Profesor: Jorge Luis Mayta Guillermo</strong> </p>

<h2 align="center">INFORME</h2>

<h3 align="center">Startup: Grupo 3</h3>
<p align="center"><strong>Producto: Workstation</strong></p>

<h3 align="center">Team Members:</h3>

<div align="center">

| **Member**               | **Code**   |
|--------------------------|------------|
| Rodrigo Liberato Saldana | U202215623 |
| Berrocal Ramirez Omar    | U20201B529 |
|                          |            |
|                          |            |
|                          |            |

</div>

<p align="center"><strong>Septiembre 2025</strong></p>

# Registro de Versiones del Informe

# Project Report Collaboration Insights

## Contenido

### Tabla de contenidos

- [Student Outcome (ver anexo A)](#student-outcome-ver-anexo-a)
- [Objetivos SMART](#objetivos-smart)
- [Capítulo I: Presentación](#capítulo-i-presentación)

  - [1.1. Startup Profile](#11-startup-profile)
    - [1.1.1. Descripción de la Startup](#111-descripción-de-la-startup)
    - [1.1.2. Perfiles de integrantes del equipo](#112-perfiles-de-integrantes-del-equipo)
  - [1.2. Solution Profile](#12-solution-profile)
    - [1.2.1. Antecedentes y problemática](#121-antecedentes-y-problemática)
    - [1.2.2. Lean UX Process](#122-lean-ux-process)
      - [1.2.2.1. Lean UX Problem Statements](#1221-lean-ux-problem-statements)
      - [1.2.2.2. Lean UX Assumptions](#1222-lean-ux-assumptions)
      - [1.2.2.3. Lean UX Hypothesis Statements](#1223-lean-ux-hypothesis-statements)
      - [1.2.2.4. Lean UX Canvas](#1224-lean-ux-canvas)
  - [1.3. Segmentos objetivo](#13-segmentos-objetivo)

- [Capítulo II: Requirements Development and Software Solution Design](#capítulo-ii-requirements-development-and-software-solution-design)
  - [2.1. Competidores](#21-competidores)
    - [2.1.1. Análisis competitivo](#211-análisis-competitivo)
    - [2.1.2. Estrategias y tácticas frente a competidores](#212-estrategias-y-tácticas-frente-a-competidores)
  - [2.2. Entrevistas](#22-entrevistas)
    - [2.2.1. Diseño de entrevistas](#221-diseño-de-entrevistas)
    - [2.2.2. Registro de entrevistas](#222-registro-de-entrevistas)
    - [2.2.3. Análisis de entrevistas](#223-análisis-de-entrevistas)
  - [2.3. Needfinding](#23-needfinding)
    - [2.3.1. User Personas](#231-user-personas)
    - [2.3.2. User Task Matrix](#232-user-task-matrix)
    - [2.3.3. User Journey Mapping](#233-user-journey-mapping)
    - [2.3.4. Empathy Mapping](#234-empathy-mapping)
    - [2.3.5. Ubiquitous Language](#235-ubiquitous-language)
  - [2.4. Requirements specification](#24-requirements-specification)
    - [2.4.1. User Stories](#241-user-stories)
    - [2.4.2. Impact Mapping](#242-impact-mapping)
    - [2.4.3. Product Backlog](#243-product-backlog)
  - [2.5. Strategic-Level Domain-Driven Design](#25-strategic-level-domain-driven-design)
    - [2.5.1. EventStorming](#251-eventstorming)
      - [2.5.1.1. Candidate Context Discovery](#2511-candidate-context-discovery)
      - [2.5.1.2. Domain Message Flows Modeling](#2512-domain-message-flows-modeling)
      - [2.5.1.3. Bounded Context Canvases](#2513-bounded-context-canvases)
    - [2.5.2. Context Mapping](#252-context-mapping)
    - [2.5.3. Software Architecture](#253-software-architecture)
      - [2.5.3.1. Software Architecture Context Level Diagrams](#2531-software-architecture-context-level-diagrams)
      - [2.5.3.2. Software Architecture Container Level Diagrams](#2532-software-architecture-container-level-diagrams)
      - [2.5.3.3. Software Architecture Deployment Diagrams](#2533-software-architecture-deployment-diagrams)
  - [2.6. Tactical-Level Domain-Driven Design](#26-tactical-level-domain-driven-design)
    - [2.6.x. Bounded Context: <Bounded Context Name>](#26x-bounded-context-bounded-context-name)
      - [2.6.x.1. Domain Layer](#26x1-domain-layer)
      - [2.6.x.2. Interface Layer](#26x2-interface-layer)
      - [2.6.x.3. Application Layer](#26x3-application-layer)
      - [2.6.x.4. Infrastructure Layer](#26x4-infrastructure-layer)
      - [2.6.x.5. Bounded Context Software Architecture Component Level Diagrams](#26x5-bounded-context-software-architecture-component-level-diagrams)
      - [2.6.x.6. Bounded Context Software Architecture Code Level Diagrams](#26x6-bounded-context-software-architecture-code-level-diagrams)
        - [2.6.x.6.1. Bounded Context Domain Layer Class Diagrams](#26x61-bounded-context-domain-layer-class-diagrams)
        - [2.6.x.6.2. Bounded Context Database Design Diagram](#26x62-bounded-context-database-design-diagram)

---

## Student Outcome (ver anexo A)

En el siguiente cuadro se describe las acciones realizadas y enunciados de conclusiones por parte del grupo, que permiten sustentar el haber alcanzado el logro del ABET – EAC - Student Outcome 7.

| Criterio específico                                                                                                                     | Acciones realizadas | Conclusiones |
|-----------------------------------------------------------------------------------------------------------------------------------------|---------------------|--------------|
| Actualiza conceptos y conocimientos necesarios para su desarrollo profesional y en especial para su proyecto en soluciones de software. |                     |              |
| Reconoce la necesidad del aprendizaje permanente para el desempeño profesional y el desarrollo de proyectos en soluciones de software.  |                     |              |

## Objetivos SMART

# Capítulo I: Presentación

## 1.1. Startup Profile

En esta sección se describe la startup, su misión, visión y los perfiles de los integrantes del equipo.

### 1.1.1. Descripción de la Startup

**PinkCell Coders** es una startup de tecnología que se especializa en el desarrollar aplicaciones móviles innovadoras y soluciones de software personalizadas en el sector del coworking con la aplicación WorkStation. Este aplicativo móvil está diseñada para facilitar  la reserva eficiente de espacios de trabajo en oficinas compartidas. Su propósito es conectar a freelancers, trabajadores remotos, startups y empresas de todos los tamaños con espacios de coworking disponibles en su ciudad o alrededor del mundo.
Con una cultura basada en métodos ágiles y la experiencia de usuario, PinkCellCoders aspira a ser un referente a nivel regional en el desarrollo de soluciones tecnológicas que impulsen la productividad y la colaboración en el entorno laboral moderno.

**Misión:** 

Construir soluciones digitales innovadoras que transformen la forma en que las personas trabajan, colaboran y se conectan en el entorno laboral moderno.

**Visión:**

Ser una startup referente en el desarrollo de soluciones digitales para espacios de coworking, que brinda a los usuarios una experiencia ágil, confiable, personalizada y una solución de gestión eficiente que maximice los beneficios de los usuarios.
### 1.1.2. Perfiles de integrantes del equipo
| Foto                                           | Alumno                          | Descripción                                                                                                                                           |
|------------------------------------------------|---------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|
| ![Omar](assets\chapter-I\Intergrante-Omar.jpg) | Berrocal Ramirez Omar Christian | Soy estudiante de la carrera de Ingeniería de Software en la Universidad Peruana de Ciencias Aplicadas (UPC). Me considero una persona que le gusta asumir nuevos retos y muy capaz. Además considero importante la cualidad de saber escuchar y respetar la opinión de los demás, así se aprende algo nuevo siempre. Mis hoobies son el baile y los videojuegos, siendo este último que me hizo optar por una carrera relacionada a la tecnología y mis gustos. |
|                                                |                                 |                                                                                                                                                       |
|                                                |                                 ||
|                                                |                                 ||
|                                                |                                 ||
## 1.2. Solution Profile

### 1.2.1. Antecedentes y problemática

### 1.2.2. Lean UX Process

#### 1.2.2.1. Lean UX Problem Statements

#### 1.2.2.2. Lean UX Assumptions

#### 1.2.2.3. Lean UX Hypothesis Statements

#### 1.2.2.4. Lean UX Canvas

## 1.3. Segmentos objetivo

# Capítulo II: Requirements Development and Software Solution Design

## 2.1. Competidores

### 2.1.1. Análisis competitivo

### 2.1.2. Estrategias y tácticas frente a competidores

## 2.2. Entrevistas

### 2.2.1. Diseño de entrevistas

### 2.2.2. Registro de entrevistas

### 2.2.3. Análisis de entrevistas

## 2.3. Needfinding

### 2.3.1. User Personas

### 2.3.2. User Task Matrix

### 2.3.3. User Journey Mapping

### 2.3.4. Empathy Mapping

### 2.3.5. Ubiquitous Language

## 2.4. Requirements specification

### 2.4.1. User Stories

### 2.4.2. Impact Mapping

### 2.4.3. Product Backlog

## 2.5. Strategic-Level Domain-Driven Design

### 2.5.1. EventStorming

#### 2.5.1.1. Candidate Context Discovery

#### 2.5.1.2. Domain Message Flows Modeling

#### 2.5.1.3. Bounded Context Canvases

### 2.5.2. Context Mapping

### 2.5.3. Software Architecture

#### 2.5.3.1. Software Architecture Context Level Diagrams

#### 2.5.3.2. Software Architecture Container Level Diagrams

#### 2.5.3.3. Software Architecture Deployment Diagrams

## 2.6. Tactical-Level Domain-Driven Design

### 2.6.1. Bounded Context: User

En esta seccion seccion, el Contexto de Usuario abarca nuestros dos segmentos objetivos, siendo personas que buscan las oficinas para rentar y las Personas que podran ofrecer estas oficinas. Si bien tienen diferentes roles, solo las personas que se registren con el objetivo de registrar las oficinas tendran esa opcion habilitada.

**Nombre de la clase:** User
**Proposito:** Albergar la informacion personal de los usuarios que se registren en la aplicacion.
**Atributos y metodos:** Los atributos que posee son:UserId, FirstName, LastName, Dni, PhoneNumber, Email, Role y CreatedAt. Los metodos principales que posee son los de CreateUser(), UpdateUser() y DeleteUser().
**Relaciones:** Mantiene una relacion la clase de Offices debido a que es la principal clase de la aplicacion y los usuarios con el rol indicado podran tener el acceso a tener muchas oficinas a la renta, ademas de la clase Messages y Rating, que se basan en el accionar del usuario y podran tener muchas.

#### 2.6.1.1. Domain Layer

En esta seccion se ira mas a profundidad acerca de lo que posee la capa del Dominio.

**Entidades:** Las entidades que posee este contexto son: User
**Value Objects**: Los Value Objects son: UserRole
**Domain Services:** Los servicios son tales como el CreateUser, delete, update, Login, IHash y IJwtEncrypt para la seguridad del usuario.
**Repositories**: Se accedio por los datos por medio de un Repositorio, IUserRepository con los emtodos de GetByEmailAsync, GetPhoneNumberAsync y GetByDniAsync.

#### 2.6.1.2. Interface Layer

Las clases de presentacion que se crearon para la presentacion de los usuarios fue utilizando REST ademas de utilizar recursos y transformadores para que se muestre solo la informacion requerida.

**Controllers:** El UserController posee endpoints como GetAllUsers, GetUserById, CreateUser, UpdateUser, DeleteUser y Login.
**Resources and Transformers:** Los recursos que se crearon para este contexto fue el de UserResource que posee firstName, lastName, dni, phoneNumber, email, roles y password. Asimismo se creo un transformador para recibir la misma informacion desde el otro lado donde se use la API.

#### 2.6.1.3. Application Layer

Para manejar los procesos de negocio, aqui se encuentran los servicios de Comandos, Queries y Hash.

**Commandos:** UserCommand posee los comandos basicos mencionados con anterioridad (create, update, delete y login) ademas de poseer validaciones con los datos que se ingresan en la Aplicacion.
**Queries:** UserQuery posee dos metodos, GetAllUsers y GetUserById, estos se usan para algunas validaciones o para mostrar datos por medio de la capa de Interfaz.
**Hash:** Para la seguridad del usuario se encriptan las contraseñas con los servicios de Hash y JwtEncript.

#### 2.6.1.4. Infrastructure Layer

Para los servicios externos solo se creo un Repositorio:

**Repositorio:** UserRepository maneja la informacion para verificaciones de Dni, Email y numero de celular

#### 2.6.1.5. Bounded Context Software Architecture Component Level Diagrams

![ComponentDiagram1](https://github.com/WorkStation-MarronCoders/Report/raw/main/Imagenes/DDD4_UserAP.png)

#### 2.6.1.6. Bounded Context Software Architecture Code Level Diagrams

##### 2.6.1.6.1. Bounded Context Domain Layer Class Diagrams

![ClassDiagram](https://media.discordapp.net/attachments/766316535290789908/1417671581634924664/XL9jJW8n4FtVK_IdHE406wCiB2g9ebdb08KECaa_IDl56FNkjhDGTzM4FxkTDwzltinqx8DmeT6AhPNmda-4Xva96Dxv1-FydCybB_XjWvAYgGCHG5Rn4-7qUq4Db7gm4ZVu9tTDoQK7HqfeGWliP1BguYrpxijrm7sIM5chs1TZO1fD2hLLGBRAkfujgh9wh6CmMJvFwHYfr0HnYJVa.png?ex=68cb550c&is=68ca038c&hm=993b1bfb6192bdf31c4f2dc5fda1141347898ce7803f7ad3a200245b961a4372&=&format=webp&quality=lossless)

##### 2.6.1.6.2. Bounded Context Database Design Diagram

![DatabaseDiagram](https://media.discordapp.net/attachments/766316535290789908/1417671581236461609/XLBDIiD04BxdAOQS6h5IXLvAAQssnT1Qef07c6H7Cf1iT7TI4UExknkgJGJnakpEzpCpNxAqWaQQgWn82yixXBTeQTETGq0BcRkUe8y0u09Y1JDeDBysnCeZpqm6vlDajrWumfqX559hzt0yvLx25JdWeLQU-Xk1GxhVEpYrP3fhrkAlBvwW-jLlPcnNkV3HcsGimMVmCxfdssxgnf_-.png?ex=68cb550c&is=68ca038c&hm=dee65a9589aa9ee8646c03c5ba2fdb8d8b659bee7e3eef35d38b85c305a733c0&=&format=webp&quality=lossless)

---

### 2.6.2. Bounded Context: Office

Office es el principal contexto que se utiliza en la aplicacion, debido a que es donde se manejan la creacion de las oficinas, las reservas, los servicios ofrecidos y cuando es que sera posible de reservar nuevamente.l

**Nombre de la clase:** Office
**Proposito:** Albergar la informacion de las oficinas que se registren por parte de los Dueños de oficinas en la aplicacion, ademas de mostrar su disponibilidad y la cantidad de servicios.
**Atributos y metodos:** Los atributos que posee son: OfficeId, Location, Description, ImageUrl, Capacity, CostPerDay, IsActive, Available y Services. Los metodos principales que posee son los de CreateOffice(), UpdateOffice(), DeleteOffice(), asimismo de la creacion de Servicios de oficinas. En cuanto a los Queries, poseen GetAllOffices, GetOfficeById y GetOfficeByLocation.
**Relaciones:** Mantiene una relacion las clases de Users y Rating debido a que las oficinas solo pueden tener un dueño y tener muchos ratings.

#### 2.6.2.1. Domain Layer

En esta seccion se ira mas a profundidad acerca de lo que posee la capa del Dominio.

**Entidades:** Las entidades que posee este contexto son: Office
**Value Objects**: Los Value Objects son: OfficeService
**Domain Services:** Los servicios son tales como el Create, Delete, Update por parte de las oficinas y los servicios de las oficinas.
**Repositories**: Se accedio por los datos por medio de un Repositorio, IOfficeRepository con los emtodos de GetByLocationAsync.

#### 2.6.2.2. Interface Layer

Las clases de presentacion que se crearon para la presentacion de los usuarios fue utilizando REST ademas de utilizar recursos y transformadores para que se muestre solo la informacion requerida.

**Controllers:** El OfficeController posee endpoints como GetAllOfficesAsync, GetOfficeByIdAsync, GetOfficeByLocationAsync, CreateOfficeAsync, UpdateOfficeAsync y DeleteOfficeAsync.
**Resources and Transformers:** Los recursos que se crearon para este contexto fue el de OfficeResource que posee Location, Description, ImageUrl, Capacity, CostPerDay, Available y una lista de OfficesResource, que posee a su vez: Name, Description y Cost. Asimismo se creo un transformador para recibir la misma informacion desde el otro lado donde se use la API.

#### 2.6.2.3. Application Layer

Para manejar los procesos de negocio, aqui se encuentran los servicios de Comandos y Queries.

**Commandos:** OfficeCommand posee los comandos basicos mencionados con anterioridad (create, update y delete) ademas de poseer validaciones con los datos que se ingresan en la aplicacion.
**Queries:** OfficeQueryService posee dos metodos, GetAllOfficesQuery, GetOfficeByIdQuery y GetOfficeByLocation estos se usan para algunas validaciones o para mostrar datos por medio de la capa de Interfaz.

#### 2.6.2.4. Infrastructure Layer

Para los servicios externos solo se creo un Repositorio:

**Repositorio:** OfficeRepository maneja la informacion para verificaciones de Location.

#### 2.6.2.5. Bounded Context Software Architecture Component Level Diagrams

![ComponentDiagram2](https://github.com/WorkStation-MarronCoders/Report/raw/main/Imagenes/DDD5_officeAP.png)

#### 2.6.2.6. Bounded Context Software Architecture Code Level Diagrams

##### 2.6.2.6.1. Bounded Context Domain Layer Class Diagrams

![ClassDiagram](https://media.discordapp.net/attachments/766316535290789908/1417678179551805551/XLFTJi8m5BxVKpIx0dKNtYu4mM4C2Vv4vG5ATo0dwTQbFP0OzDrjj-Ceq-WDhD_vThwVT3D7qjA-qedIqZbnAntSrOJqBew949TYMOfStE-nR4-51KbGBloFXyFV6rRGZXvCYLlyCRjfXsi7jjs4DNL0KuP5CTunbswk20zXnSOOdNmcxEnfkqK5x6fbb2GqjMSvibZlMdG1JbbipWQy.png?ex=68cb5b31&is=68ca09b1&hm=827dff612fb42a3147106daea4b2674a016ddac888f9fbcfb2567d488ec9c255&=&format=webp&quality=lossless)

##### 2.6.2.6.2. Bounded Context Database Design Diagram

![DatabaseDiagram](https://media.discordapp.net/attachments/766316535290789908/1417678179551805551/XLFTJi8m5BxVKpIx0dKNtYu4mM4C2Vv4vG5ATo0dwTQbFP0OzDrjj-Ceq-WDhD_vThwVT3D7qjA-qedIqZbnAntSrOJqBew949TYMOfStE-nR4-51KbGBloFXyFV6rRGZXvCYLlyCRjfXsi7jjs4DNL0KuP5CTunbswk20zXnSOOdNmcxEnfkqK5x6fbb2GqjMSvibZlMdG1JbbipWQy.png?ex=68cb5b31&is=68ca09b1&hm=827dff612fb42a3147106daea4b2674a016ddac888f9fbcfb2567d488ec9c255&=&format=webp&quality=lossless)

---

### 2.6.3. Bounded Context: Rating

Rating es el contexto que se utiliza en la aplicacion para dar una opiniion acerca de la oficins que han entrado en el estado de renta. Esta tiene conexion con la clase de Office.

**Nombre de la clase:** Rating
**Proposito:** Albergar la informacion de las opiniones de oficinas que se registren por parte de los Usuarios que van a pagar por esas oficinas.
**Atributos y metodos:** Los atributos que posee son: RatingId, Score, Content, OfficeId y CreatedAt. Los metodos principales que posee son los de CreateRating() y GetRatingsByOffice().
**Relaciones:** Mantiene una relacion las clases de Users y Office debido a que las oficinas pueden tener muchas opiniones.

#### 2.6.3.1. Domain Layer

En esta seccion se ira mas a profundidad acerca de lo que posee la capa del Dominio.

**Entidades:** Las entidades que posee este contexto son: Ratinh
**Domain Services:** Los servicios son tales como el Create y el GetRatingsByOffice.
**Repositories**: Se accedio por los datos por medio de un Repositorio, IratingRepository con los emtodos de GetByOfficeIdAsync.

#### 2.6.3.2. Interface Layer

Las clases de presentacion que se crearon para la presentacion de los usuarios fue utilizando REST.

**Controllers:** El RatingController posee endpoints como CreateRatingAsync, GetRatingsByOfficeAsync y GetAverageRatingByOfficeAsync.

#### 2.6.3.3. Application Layer

Para manejar los procesos de negocio, aqui se encuentran los servicios de Comandos.

**Commandos:** RatingCommandService posee un unico comando que seria el de CreateRatingAsync.

#### 2.6.3.4. Infrastructure Layer

Para los servicios externos solo se creo un Repositorio:

**Repositorio:** RatingRepository maneja la informacion para verificaciones de GetByOfficeIdAsync.

#### 2.6.3.5. Bounded Context Software Architecture Component Level Diagrams

![ComponentDiagram3](https://github.com/WorkStation-MarronCoders/Report/blob/main/Imagenes/DDD_rating.png)

#### 2.6.3.6. Bounded Context Software Architecture Code Level Diagrams

##### 2.6.3.6.1. Bounded Context Domain Layer Class Diagrams

![ClassDiagram](https://media.discordapp.net/attachments/766316535290789908/1417919309644173485/ZPBFRi8m38VlVOgeHwOUTaM8ZPLfGc9_DCO3cDGWIsc24eCqRNltfKaKXNBOJj3Fxi-Vqzmx1ikdNbLIWNFY0Hm-QYR-55-L43TYrOcfU3fH5vvQYy3OBO7Hu-7dWteCfMVJqPwkQdUXk7LeGn9fZk3O3K4bZvqhjv1CP_HiPuogVgfazhhVayHajJOIc8psNOujwKEWItJIql6Ya5.png?ex=68cc3bc3&is=68caea43&hm=91c93664e3ba518334629a459bbee1a020b7da11bd92298a6cfab04759cd83ba&=&format=webp&quality=lossless&width=794&height=906)

##### 2.6.3.6.2. Bounded Context Database Design Diagram

![DatabaseDiagram](https://media.discordapp.net/attachments/766316535290789908/1417919310386692237/fLDHQy8m47xlhmXzqZ57tUYBYEXqGj4vcVW3pkJKG9kw91Q6tNzVqgurb3d7zj8cztrtztt7PQWqI7rCOW-5vlgT-8-WyAau-mGKsPZh5tJo2BaX4ICzSXJyxOYSMMJBKP9-VpaR30nXB14qiedv61upFyqJDC1poYorYP35UZuty5gXB4fpeUtrO0dCZLRCI8sevfajik7Q-_1gwI.png?ex=68cc3bc3&is=68caea43&hm=e59e084fc66b78eac7c77d783c44f1692bc6746af9165ab1065e24c50bfd379c&=&format=webp&quality=lossless&width=1176&height=906)